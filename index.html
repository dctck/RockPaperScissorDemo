<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rock Paper Scissors - NFT Battle (Deck Sim)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.3/dist/confetti.browser.min.js"></script>
    <style>
        /* Basic styling from previous version */
        body {
            font-family: 'Inter', sans-serif; background-color: #1a202c; color: #e2e8f0; display: flex; justify-content: center; align-items: center; min-height: 100vh; padding: 1rem; }
        #game-container { width: 100%; max-width: 48rem; margin-top: 1rem; margin-bottom: 1rem; }
        .card { width: 100px; height: 140px; border: 2px solid #4a5568; border-radius: 0.5rem; display: flex; flex-direction: column; justify-content: center; align-items: center; font-size: 3rem; background-color: #2d3748; margin: 0.5rem; transition: transform 0.3s ease, box-shadow 0.3s ease, opacity 0.4s ease, filter 0.4s ease, border-color 0.3s ease; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3); position: relative; overflow: hidden; }
        .card.winner { border-color: #38a169; box-shadow: 0 0 15px rgba(56, 161, 105, 0.7); transform: scale(1.05); }
        .card.loser { border-color: #718096; opacity: 0.6; filter: grayscale(80%); }
        .card.draw { border-color: #f59e0b; transform: scale(1.02); }
        .inventory-card { width: 70px; height: 100px; font-size: 2rem; margin: 0.3rem; border-width: 1px; }
        .round-indicator { width: 20px; height: 20px; border: 2px solid #4a5568; border-radius: 50%; display: inline-block; margin: 0 5px; background-color: transparent; transition: background-color 0.3s ease; }
        .round-indicator.won { background-color: #38a169; border-color: #38a169; }
        .win-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.85); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 100; opacity: 0; visibility: hidden; transition: opacity 0.5s ease, visibility 0s linear 0.5s; }
        .win-screen.show { opacity: 1; visibility: visible; transition: opacity 0.5s ease; }
        @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }
        .pulse-button { animation: pulse 2s infinite; }
        .hidden { display: none; }

        /* Modal Styles */
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); display: flex; justify-content: center; align-items: center; z-index: 50; opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0s linear 0.3s; }
        .modal-overlay.show { opacity: 1; visibility: visible; transition: opacity 0.3s ease; }
        .modal-content { background-color: #2d3748; padding: 1.5rem; border-radius: 0.5rem; border: 1px solid #4a5568; min-width: 350px; max-width: 90%; box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5); transform: scale(0.95); transition: transform 0.3s ease; }
        .modal-overlay.show .modal-content { transform: scale(1); }
        .modal-content label { margin-right: 0.5rem; font-weight: 500; }
        .modal-content select, .modal-content input[type="number"] { background-color: #4a5568; border: 1px solid #718096; color: #e2e8f0; padding: 0.3rem 0.5rem; border-radius: 0.25rem; margin-right: 0.5rem; }
        .modal-content input[type=number]::-webkit-inner-spin-button, .modal-content input[type=number]::-webkit-outer-spin-button { opacity: 1; background-color: #718096; border-radius: 2px; }
        .modal-content button { padding: 0.4rem 0.8rem; border-radius: 0.3rem; font-weight: 600; transition: background-color 0.2s ease; margin-left: 0.5rem; }
        .btn-confirm { background-color: #38a169; color: #fff; } .btn-confirm:hover { background-color: #2f855a; } .btn-confirm:disabled { background-color: #4a5568; cursor: not-allowed; }
        .btn-cancel { background-color: #e53e3e; color: #fff; } .btn-cancel:hover { background-color: #c53030; }
        .btn-action-toggle { background-color: #4a5568; color: #e2e8f0; margin: 0 0.5rem; } .btn-action-toggle:hover { background-color: #718096; }
        .modal-feedback { text-align: center; margin-top: 0.5rem; height: 1.25rem; font-weight: 500; }
        .feedback-success { color: #48bb78; } .feedback-error { color: #f56565; }

        /* Deck Selection Modal Styles */
        #deck-selection-modal .modal-content { min-width: 400px; }
        .deck-input-group { display: flex; align-items: center; margin-bottom: 0.75rem; justify-content: space-between; }
        .deck-input-group label { flex-basis: 100px; text-align: right; }
        .deck-input-group input[type="number"] { width: 60px; text-align: center; margin: 0 0.5rem; }
        .deck-input-group .inventory-count { font-size: 0.8rem; color: #a0aec0; }
        #deck-total-display { font-weight: bold; margin-top: 1rem; text-align: center; height: 1.5rem; }
        #deck-total-display.invalid { color: #f56565; }
        #deck-total-display.valid { color: #48bb78; }

        /* Battle Start Popup */
        #battle-start-popup { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0.8); background-color: rgba(20, 30, 48, 0.9); color: #ff9800; padding: 2rem 3rem; border-radius: 1rem; font-size: 2.5rem; font-weight: bold; text-align: center; z-index: 110; border: 3px solid #ff9800; opacity: 0; visibility: hidden; transition: opacity 0.3s ease, transform 0.3s ease, visibility 0s linear 0.3s; box-shadow: 0 0 15px 5px rgba(255, 152, 0, 0.5); }
        #battle-start-popup.show { opacity: 1; visibility: visible; animation: battle-start-anim 0.5s ease-out forwards, fire-effect 1.5s infinite alternate; }
        @keyframes battle-start-anim { 0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; } 50% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; } 100% { transform: translate(-50%, -50%) scale(1); opacity: 1; } }
        @keyframes fire-effect { 0% { box-shadow: 0 0 15px 5px rgba(255, 152, 0, 0.5), 0 0 5px 2px rgba(255, 87, 34, 0.4); } 100% { box-shadow: 0 0 25px 8px rgba(255, 152, 0, 0.7), 0 0 8px 3px rgba(255, 87, 34, 0.6); } }

        /* Roulette Animation Placeholder */
        .roulette-item { font-size: 3rem; text-align: center; }

        /* Attack Animation */
        @keyframes attack-p1 { 0% { transform: translateX(0) rotate(0); } 50% { transform: translateX(80px) rotate(15deg) scale(1.1); } 100% { transform: translateX(0) rotate(0); } }
        @keyframes attack-p2 { 0% { transform: translateX(0) rotate(0); } 50% { transform: translateX(-80px) rotate(-15deg) scale(1.1); } 100% { transform: translateX(0) rotate(0); } }
        .attacking-p1 { animation: attack-p1 0.6s ease-in-out; }
        .attacking-p2 { animation: attack-p2 0.6s ease-in-out; }

        /* ENJ Coin Style */
        .enj-coin { display: inline-flex; justify-content: center; align-items: center; width: 1.1rem; height: 1.1rem; border-radius: 50%; background-color: #805ad5; color: white; font-size: 0.75rem; font-weight: bold; line-height: 1; text-align: center; vertical-align: middle; margin: 0 0.1rem; box-shadow: 0 1px 2px rgba(0,0,0,0.3); }
        .enj-inline { display: inline-flex; align-items: center; }

        /* Ante Feedback Style */
        #ante-feedback { color: #f56565; font-size: 0.875rem; height: 1.25rem; margin-top: 0.5rem; }

        /* Betting Controls Styles */
        #betting-info { margin-bottom: 1rem; font-weight: 500; }
        #pot-display { font-weight: bold; color: #a3bffa; }
        #player1-action-display { font-style: italic; color: #bee3f8; height: 1.25rem; margin-top: 0.5rem; }
        #player2-action-display { font-style: italic; color: #90cdf4; height: 1.25rem; margin-top: 0.5rem; }
        #betting-controls button { padding: 0.5rem 1rem; margin: 0 0.25rem; border-radius: 0.3rem; font-weight: 600; transition: background-color 0.2s ease; }
        #betting-controls button:disabled { background-color: #4a5568; cursor: not-allowed; opacity: 0.7; }
        .btn-call { background-color: #3182ce; color: white; } .btn-call:hover:not(:disabled) { background-color: #2b6cb0; }
        .btn-raise { background-color: #dd6b20; color: white; } .btn-raise:hover:not(:disabled) { background-color: #c05621; }
        .btn-forfeit { background-color: #718096; color: white; } .btn-forfeit:hover:not(:disabled) { background-color: #4a5568; }

        /* Big Pot Display Styles */
        #main-pot-display { border: 2px solid #4a5568; background-color: rgba(45, 55, 72, 0.5); border-radius: 0.5rem; padding: 0.5rem 1rem; margin-bottom: 1.5rem; }
        #main-pot-display .pot-label { font-size: 0.875rem; color: #a0aec0; text-transform: uppercase; letter-spacing: 0.05em; }
         #main-pot-display .pot-amount { font-size: 2.25rem; font-weight: bold; color: #fbd38d; line-height: 1.1; }
         #main-pot-display .enj-coin { width: 1.5rem; height: 1.5rem; font-size: 1rem; margin-left: 0.25rem; }

        /* Timer Style */
        #betting-timer-display { margin-top: 0.75rem; font-size: 1.1rem; }
        #betting-timer.timer-warning { color: #f56565; font-weight: bold; } /* Red warning */

        /* Auto-Play Indicator Style */
         #auto-play-indicator { position: absolute; top: 5px; right: 10px; background-color: rgba(30, 41, 59, 0.8); color: #60a5fa; padding: 2px 8px; border-radius: 4px; font-size: 0.75rem; font-weight: 500; border: 1px solid #60a5fa; z-index: 10; }
         #auto-play-indicator span { animation: pulse 1.5s infinite ease-in-out; }

    </style>
</head>
<body class="bg-gray-900 text-gray-200">

    <div id="game-container" class="w-full max-w-4xl mx-auto p-6 bg-gray-800 rounded-lg shadow-xl text-center relative">

        <h1 class="text-3xl font-bold mb-4 text-teal-400">Rock Paper Scissors - NFT Battle (Simulated)</h1>
        <p class="text-sm text-gray-400 mb-6">This is a simulation with a mock economy. No real assets are used.</p>

        <div id="my-cards-screen">
             <h2 class="text-2xl font-semibold mb-4 text-teal-300">My Profile & Cards</h2>
             <div id="player-profile" class="mb-6 p-4 bg-gray-700 rounded-lg shadow">
                 <h3 class="text-lg font-medium mb-2">Session Stats (Player 1)</h3>
                 <div class="flex justify-around flex-wrap"> <p class="mx-2">Matches Won: <span id="total-wins" class="font-bold text-green-400">0</span></p>
                    <p class="mx-2">Matches Lost: <span id="total-losses" class="font-bold text-red-400">0</span></p>
                    <p class="mx-2">Balance: <span id="enj-balance" class="font-bold text-purple-400">0</span><span class="enj-coin">E</span> ENJ</p>
                 </div>
             </div>
             <div class="mb-4">
                 <h3 class="text-lg font-medium mb-3">My Current Inventory</h3>
                 <div id="my-cards-display" class="flex justify-center items-center flex-wrap gap-4 p-4 bg-gray-700 rounded-lg shadow min-h-[120px]">
                     <p class="text-gray-400">Initializing inventory...</p>
                 </div>
             </div>
             <div class="mb-4">
                  <button id="buy-button" class="btn-action-toggle">Buy Cards</button>
                  <button id="sell-button" class="btn-action-toggle">Sell Cards</button>
             </div>
             <div id="controls" class="mt-6">
                  <button id="challenge-button" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-lg text-lg transition duration-200 pulse-button">
                     Start Battle (Ante: 5<span class="enj-coin !w-3 !h-3 !text-[0.6rem] mx-0.5">E</span>) </button>
                  <p id="ante-feedback"></p> </div>
        </div>

        <div id="game-area" class="hidden relative">
             <div id="auto-play-indicator" class="hidden"> <span>▶️ Auto Playing...</span> </div>
             <h2 class="text-2xl font-semibold mb-4 text-yellow-300">Battle Arena</h2>
             <div id="main-pot-display" class="text-center mb-4">
                 <span class="pot-label">Pot</span>
                 <div class="pot-amount"> <span id="main-pot-amount">0</span><span class="enj-coin">E</span> </div>
             </div>
             <div class="flex justify-around items-start mb-6">
                 <div class="w-1/3 text-center">
                     <h3 class="text-xl font-semibold mb-3">Player 1</h3>
                     <div id="player1-indicators" class="mb-4">
                         <span class="round-indicator"></span><span class="round-indicator"></span><span class="round-indicator"></span>
                     </div>
                     <div id="player1-card" class="card mx-auto">?</div>
                     <p class="text-sm text-gray-400 mt-2">Deck: <span id="player1-deck-count">10</span></p>
                 </div>
                 <div class="w-1/3 text-center pt-8"> <p id="round-result" class="text-lg font-medium h-8 mb-2"></p>
                     <p id="draw-info" class="text-yellow-400 text-sm h-6 mb-2"></p>
                     <div id="betting-info" class="mb-4 hidden">
                         <p class="text-sm">Current Pot: <span id="pot-display">10</span><span class="enj-coin">E</span></p>
                         <p id="betting-timer-display" class="text-lg font-semibold mt-2 hidden">Time Left: <span id="betting-timer" class="text-xl">10</span>s</p> <p id="player1-action-display"></p> <p id="player2-action-display"></p> <p id="betting-feedback" class="feedback-error h-5 text-sm"></p> </div>
                     <div id="betting-controls" class="hidden">
                         <button id="call-button" class="btn-call">Call / Next Round</button>
                         <button id="raise-button" class="btn-raise">Raise (5<span class="enj-coin !w-3 !h-3 !text-[0.6rem] mx-0.5">E</span>)</button>
                         <button id="forfeit-button" class="btn-forfeit">Forfeit</button>
                     </div>
                     <button id="next-round-button" class="hidden bg-yellow-500 hover:bg-yellow-600 text-gray-900 font-bold py-2 px-4 rounded-lg transition duration-200">Next Round</button>
                     </div>
                 <div class="w-1/3 text-center">
                     <h3 class="text-xl font-semibold mb-3">Player 2</h3>
                      <div id="player2-indicators" class="mb-4">
                         <span class="round-indicator"></span><span class="round-indicator"></span><span class="round-indicator"></span>
                     </div>
                     <div id="player2-card" class="card mx-auto">?</div>
                     <p class="text-sm text-gray-400 mt-2">Deck: <span id="player2-deck-count">10</span></p>
                 </div>
             </div>
        </div>
    </div>

    <div id="deck-selection-modal" class="modal-overlay">
        <div class="modal-content">
            <h4 class="text-lg font-semibold mb-4 text-blue-300 text-center">Choose Your Battle Deck (Total 10 Cards)</h4>
            <div class="deck-input-group">
                <label for="deck-r-count">Rock ✊:</label>
                <input type="number" id="deck-r-count" min="0" value="4" class="deck-input">
                <span class="inventory-count">(Inv: <span id="inv-r-count">0</span>)</span>
            </div>
            <div class="deck-input-group">
                <label for="deck-p-count">Paper ✋:</label>
                <input type="number" id="deck-p-count" min="0" value="3" class="deck-input">
                 <span class="inventory-count">(Inv: <span id="inv-p-count">0</span>)</span>
            </div>
            <div class="deck-input-group">
                <label for="deck-s-count">Scissor ✌️:</label>
                <input type="number" id="deck-s-count" min="0" value="3" class="deck-input">
                 <span class="inventory-count">(Inv: <span id="inv-s-count">0</span>)</span>
            </div>
            <div id="deck-total-display">Total: 10 / 10</div>
            <p id="deck-feedback" class="modal-feedback feedback-error"></p>
            <div class="flex justify-end mt-4">
                <button id="confirm-deck-button" class="btn-confirm">Confirm Deck & Battle!</button>
                <button id="cancel-deck-button" class="btn-cancel">Cancel</button>
            </div>
        </div>
    </div>


    <div id="buy-modal" class="modal-overlay"> <div class="modal-content"> <h4 class="text-lg font-semibold mb-4 text-green-300 text-center">Buy Cards</h4> <div class="text-center text-sm text-gray-400 mb-3"> <span>Price: <span id="buy-price" class="font-semibold text-purple-400">--</span><span class="enj-coin">E</span></span> | <span>Available: <span id="buy-available" class="font-semibold text-blue-400">--</span></span> </div> <div class="mb-3"> <label for="buy-type-select">Card:</label> <select id="buy-type-select"> <option value="R">Rock ✊</option> <option value="P">Paper ✋</option> <option value="S">Scissor ✌️</option> </select> <span class="text-sm mx-2">(Owned: <span id="buy-current-count">0</span>)</span> </div> <div class="mb-4"> <label for="buy-quantity">Quantity:</label> <input type="number" id="buy-quantity" min="1" value="1" class="w-16"> <span class="text-sm ml-2">Cost: <span id="buy-total-cost" class="font-semibold text-purple-400">0</span><span class="enj-coin">E</span></span> </div> <p id="buy-feedback" class="modal-feedback"></p> <div class="flex justify-end mt-4"> <button id="confirm-buy-button" class="btn-confirm">Confirm Buy</button> <button id="cancel-buy-button" class="btn-cancel">Cancel</button> </div> </div> </div>
     <div id="sell-modal" class="modal-overlay"> <div class="modal-content"> <h4 class="text-lg font-semibold mb-4 text-red-300 text-center">Sell Cards</h4> <div class="text-center text-sm text-gray-400 mb-3"> <span>Price: <span id="sell-price" class="font-semibold text-purple-400">--</span><span class="enj-coin">E</span></span> | <span>Available: <span id="sell-available" class="font-semibold text-blue-400">--</span></span> </div> <div class="mb-3"> <label for="sell-type-select">Card:</label> <select id="sell-type-select"> <option value="R">Rock ✊</option> <option value="P">Paper ✋</option> <option value="S">Scissor ✌️</option> </select> <span class="text-sm mx-2">(Owned: <span id="sell-current-count">0</span>)</span> </div> <div class="mb-4"> <label for="sell-quantity">Quantity:</label> <input type="number" id="sell-quantity" min="1" value="1" max="1" class="w-16"> <span class="text-sm ml-2">Earn: <span id="sell-total-earn" class="font-semibold text-purple-400">0</span><span class="enj-coin">E</span></span> </div> <p id="sell-feedback" class="modal-feedback"></p> <div class="flex justify-end mt-4"> <button id="confirm-sell-button" class="btn-confirm">Confirm Sell</button> <button id="cancel-sell-button" class="btn-cancel">Cancel</button> </div> </div> </div>

    <div id="win-screen" class="win-screen"> <h2 id="win-message" class="text-5xl font-bold mb-4"></h2> <p id="win-reward" class="text-lg text-purple-300 mb-6"></p> <button id="play-again-button" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Back to My Cards</button> </div>

    <div id="battle-start-popup"> Battle Start! </div>

    <script>
        // --- DOM Elements ---
        // (Select all elements as before) ...
        const myCardsScreen = document.getElementById('my-cards-screen');
        const playerProfile = document.getElementById('player-profile');
        const totalWinsEl = document.getElementById('total-wins');
        const totalLossesEl = document.getElementById('total-losses');
        const enjBalanceEl = document.getElementById('enj-balance');
        const myCardsDisplay = document.getElementById('my-cards-display');
        const controls = document.getElementById('controls');
        const challengeButton = document.getElementById('challenge-button');
        const anteFeedback = document.getElementById('ante-feedback');
        const gameArea = document.getElementById('game-area');
        const mainPotDisplay = document.getElementById('main-pot-display');
        const mainPotAmount = document.getElementById('main-pot-amount');
        const autoPlayIndicator = document.getElementById('auto-play-indicator');
        const nextRoundButton = document.getElementById('next-round-button');
        const player1Card = document.getElementById('player1-card');
        const player2Card = document.getElementById('player2-card');
        const player1Indicators = document.getElementById('player1-indicators').children;
        const player2Indicators = document.getElementById('player2-indicators').children;
        const player1DeckCountEl = document.getElementById('player1-deck-count');
        const player2DeckCountEl = document.getElementById('player2-deck-count');
        const roundResult = document.getElementById('round-result');
        const drawInfo = document.getElementById('draw-info');
        const winScreen = document.getElementById('win-screen');
        const winMessage = document.getElementById('win-message');
        const winReward = document.getElementById('win-reward');
        const playAgainButton = document.getElementById('play-again-button');
        const buyButton = document.getElementById('buy-button');
        const sellButton = document.getElementById('sell-button');
        const buyModal = document.getElementById('buy-modal');
        const buyTypeSelect = document.getElementById('buy-type-select');
        const buyCurrentCount = document.getElementById('buy-current-count');
        const buyQuantityInput = document.getElementById('buy-quantity');
        const buyPriceEl = document.getElementById('buy-price');
        const buyAvailableEl = document.getElementById('buy-available');
        const buyTotalCostEl = document.getElementById('buy-total-cost');
        const confirmBuyButton = document.getElementById('confirm-buy-button');
        const cancelBuyButton = document.getElementById('cancel-buy-button');
        const buyFeedback = document.getElementById('buy-feedback');
        const sellModal = document.getElementById('sell-modal');
        const sellTypeSelect = document.getElementById('sell-type-select');
        const sellCurrentCount = document.getElementById('sell-current-count');
        const sellQuantityInput = document.getElementById('sell-quantity');
        const sellPriceEl = document.getElementById('sell-price');
        const sellAvailableEl = document.getElementById('sell-available');
        const sellTotalEarnEl = document.getElementById('sell-total-earn');
        const confirmSellButton = document.getElementById('confirm-sell-button');
        const cancelSellButton = document.getElementById('cancel-sell-button');
        const sellFeedback = document.getElementById('sell-feedback');
        const battleStartPopup = document.getElementById('battle-start-popup');
        // Betting Elements
        const bettingInfo = document.getElementById('betting-info');
        const potDisplay = document.getElementById('pot-display');
        const bettingTimerDisplay = document.getElementById('betting-timer-display');
        const bettingTimer = document.getElementById('betting-timer');
        const player1ActionDisplay = document.getElementById('player1-action-display');
        const player2ActionDisplay = document.getElementById('player2-action-display');
        const bettingFeedback = document.getElementById('betting-feedback');
        const bettingControls = document.getElementById('betting-controls');
        const callButton = document.getElementById('call-button');
        const raiseButton = document.getElementById('raise-button');
        const forfeitButton = document.getElementById('forfeit-button');
        // Deck Selection Elements
        const deckSelectionModal = document.getElementById('deck-selection-modal');
        const deckRCountInput = document.getElementById('deck-r-count');
        const deckPCountInput = document.getElementById('deck-p-count');
        const deckSCountInput = document.getElementById('deck-s-count');
        const invRCountEl = document.getElementById('inv-r-count');
        const invPCountEl = document.getElementById('inv-p-count');
        const invSCountEl = document.getElementById('inv-s-count');
        const deckTotalDisplay = document.getElementById('deck-total-display');
        const deckFeedback = document.getElementById('deck-feedback');
        const confirmDeckButton = document.getElementById('confirm-deck-button');
        const cancelDeckButton = document.getElementById('cancel-deck-button');


        // --- Game State & Economy ---
        let player1Score = 0;
        let player2Score = 0;
        let currentRound = 0;
        let totalWins = 0;
        let totalLosses = 0;
        let player1ENJ = 100;
        const maxRounds = 3; // Target score to win
        const choices = { R: '✊', P: '✋', S: '✌️' };
        const choiceOrder = ['R', 'P', 'S'];
        // Main Inventory (Persistent)
        let player1Inventory = { R: 10, P: 10, S: 10 };
        // Battle Decks (Temporary for match)
        let player1BattleDeck = [];
        let player2BattleDeck = [];
        let initialP1Deck = [];
        let initialP2Deck = [];
        const battleDeckSize = 10;

        let p1RouletteInterval = null;
        let p2RouletteInterval = null;
        let isAnimating = false;
        let bettingPhaseActive = false;
        let betHasBeenRaised = false; // Tracks if pot ever reached 20 or 30
        let player1HasRaised = false; // Tracks if P1 raised this match
        let player2HasEffectivelyRaised = false; // Tracks if P2 raised or called a raise
        let autoPlayActive = false; // Tracks if pot reached 30 (mutual raise)
        let currentPot = 0;
        let storedPlayer1BetAction = null;
        let bettingTimerInterval = null;
        let bettingTimerSeconds = 10;

        // Economy Settings
        const totalSupply = { R: 50, P: 50, S: 50 };
        const basePrice = { R: 10, P: 10, S: 10 };
        const battleAnte = 5;
        const raiseAmount = 5;
        const initialPot = battleAnte * 2; // 10
        const raisedPotSingle = initialPot + raiseAmount * 2; // 20
        const raisedPotMutual = initialPot + raiseAmount * 4; // 30


        // --- Functions ---

        // --- Economy Functions ---
        function getAvailableSupply(type) { return Math.max(0, totalSupply[type] - (player1Inventory[type] || 0)); }
        function calculateCurrentPrice(type) { const available = getAvailableSupply(type); let price = basePrice[type] * (1 + (totalSupply[type] - available) / totalSupply[type]); price *= (1 + (Math.random() - 0.5) * 0.1); return Math.max(1, Math.round(price)); }
        function updateENJBalanceDisplay() { enjBalanceEl.textContent = player1ENJ; }

        // --- UI Update Functions ---
        function generateRandomInventoryArray(size = 10) { const inventory = []; const types = Object.keys(choices); for (let i = 0; i < size; i++) { inventory.push(types[Math.floor(Math.random() * types.length)]); } return inventory; }
        function updateGameInventoryCounts() { player1DeckCountEl.textContent = player1BattleDeck.length; player2DeckCountEl.textContent = player2BattleDeck.length; }
        function displayMyCards() { myCardsDisplay.innerHTML = ''; const p1Total = Object.values(player1Inventory).reduce((sum, count) => sum + count, 0); if (p1Total === 0) { myCardsDisplay.innerHTML = '<p class="text-gray-400">No cards in inventory.</p>'; } else { Object.entries(choices).forEach(([type, emoji]) => { const count = player1Inventory[type] || 0; if (count > 0) { const cardDiv = document.createElement('div'); cardDiv.className = 'card inventory-card flex flex-col items-center justify-center'; cardDiv.innerHTML = `<span class="text-3xl">${emoji}</span><span class="text-sm font-semibold mt-1">x ${count}</span>`; myCardsDisplay.appendChild(cardDiv); } }); } updateBuySellCurrentCounts(); updateENJBalanceDisplay(); }
        function updateProfileStats() { totalWinsEl.textContent = totalWins; totalLossesEl.textContent = totalLosses; updateENJBalanceDisplay(); }
        function updateBuySellCurrentCounts() { const selectedBuyType = buyTypeSelect.value; const selectedSellType = sellTypeSelect.value; const buyPrice = calculateCurrentPrice(selectedBuyType); const sellPrice = calculateCurrentPrice(selectedSellType); const buyAvailable = getAvailableSupply(selectedBuyType); const sellAvailable = getAvailableSupply(selectedSellType); buyCurrentCount.textContent = player1Inventory[selectedBuyType] || 0; buyPriceEl.textContent = buyPrice; buyAvailableEl.textContent = buyAvailable; const buyQuantity = parseInt(buyQuantityInput.value) || 0; buyTotalCostEl.textContent = buyPrice * buyQuantity; const currentSellCount = player1Inventory[selectedSellType] || 0; sellCurrentCount.textContent = currentSellCount; sellPriceEl.textContent = sellPrice; sellAvailableEl.textContent = sellAvailable; sellQuantityInput.max = currentSellCount > 0 ? currentSellCount : 1; if (parseInt(sellQuantityInput.value) > currentSellCount) { sellQuantityInput.value = currentSellCount > 0 ? currentSellCount : 1; } sellQuantityInput.disabled = currentSellCount === 0; confirmSellButton.disabled = currentSellCount === 0; const sellQuantity = parseInt(sellQuantityInput.value) || 0; sellTotalEarnEl.textContent = currentSellCount > 0 ? sellPrice * sellQuantity : 0; }
        function updateMainPotDisplay() { mainPotAmount.textContent = currentPot; }

        // --- Core Game & Animation Functions ---
        function getRandomChoice(player) { const deck = (player === 'player1') ? player1BattleDeck : player2BattleDeck; if (deck.length === 0) { console.log(`DEBUG: ${player} deck empty!`); return null; } const randomIndex = Math.floor(Math.random() * deck.length); const choice = deck.splice(randomIndex, 1)[0]; console.log(`DEBUG: ${player} draws ${choice}. Deck remaining: ${deck.length}`); updateGameInventoryCounts(); return choice; }
        function determineWinner(choice1, choice2) { if (choice1 === choice2) return 'draw'; if ((choice1 === 'R' && choice2 === 'S') || (choice1 === 'S' && choice2 === 'P') || (choice1 === 'P' && choice2 === 'R')) return 'player1'; return 'player2'; }
        function updateScoreIndicators() { for (let i = 0; i < maxRounds; i++) { if(player1Indicators[i]) { player1Indicators[i].classList.toggle('won', i < player1Score); } if(player2Indicators[i]) { player2Indicators[i].classList.toggle('won', i < player2Score); } } }
        function triggerConfetti() { const duration = 5 * 1000; const animationEnd = Date.now() + duration; const defaults = { startVelocity: 30, spread: 360, ticks: 60, zIndex: 101 }; function randomInRange(min, max) { return Math.random() * (max - min) + min; } const interval = setInterval(function() { const timeLeft = animationEnd - Date.now(); if (timeLeft <= 0) return clearInterval(interval); const particleCount = 50 * (timeLeft / duration); confetti(Object.assign({}, defaults, { particleCount, origin: { x: randomInRange(0.1, 0.3), y: Math.random() - 0.2 } })); confetti(Object.assign({}, defaults, { particleCount, origin: { x: randomInRange(0.7, 0.9), y: Math.random() - 0.2 } })); }, 250); }
        function resetCardStyles() { player1Card.className = 'card mx-auto'; player2Card.className = 'card mx-auto'; player1Card.textContent = '?'; player2Card.textContent = '?'; roundResult.textContent = ''; drawInfo.textContent = ''; }
        function startRoulette(cardElement) { let currentIndex = 0; cardElement.textContent = ''; return setInterval(() => { cardElement.textContent = choices[choiceOrder[currentIndex]]; currentIndex = (currentIndex + 1) % choiceOrder.length; }, 75); }
        function stopRoulette(intervalId, cardElement, finalChoice) { clearInterval(intervalId); cardElement.textContent = choices[finalChoice]; }
        function triggerAttackAnimation(winnerCardElement, winner) { const animationClass = winner === 'player1' ? 'attacking-p1' : 'attacking-p2'; winnerCardElement.classList.add(animationClass); setTimeout(() => { winnerCardElement.classList.remove(animationClass); }, 600); }

        // --- Particle Effect Function ---
        function shootParticles(originX, count = 70) { confetti({ particleCount: count, angle: originX < 0.5 ? 60 : 120, spread: 55, origin: { x: originX, y: 0.6 }, colors: ['#63b3ed', '#4299e1', '#90cdf4'], scalar: 0.9, disableForReducedMotion: true, gravity: 0.8 }); }


        // --- Betting Phase Functions ---
        function clearBettingTimer() { if (bettingTimerInterval) { clearInterval(bettingTimerInterval); bettingTimerInterval = null; console.log("DEBUG: Betting timer cleared."); } }
        function showBettingPhase() {
            console.log(`DEBUG: showBettingPhase called. P1 Raised: ${player1HasRaised}, P2 Raised: ${player2HasEffectivelyRaised}, AutoPlay: ${autoPlayActive}`);
            bettingPhaseActive = true; isAnimating = true;
            bettingInfo.classList.remove('hidden');
            bettingControls.classList.remove('hidden');
            nextRoundButton.classList.add('hidden');
            autoPlayIndicator.classList.add('hidden');
            potDisplay.textContent = currentPot; updateMainPotDisplay();
            player1ActionDisplay.textContent = "Your action?"; player2ActionDisplay.textContent = ""; bettingFeedback.textContent = "";
            callButton.disabled = false;
            raiseButton.disabled = player1HasRaised;
            forfeitButton.disabled = false;
            storedPlayer1BetAction = null;

            // Start Timer
            clearBettingTimer();
            bettingTimerSeconds = 10;
            bettingTimer.textContent = bettingTimerSeconds;
            bettingTimer.classList.remove('timer-warning');
            bettingTimerDisplay.classList.remove('hidden');

            bettingTimerInterval = setInterval(() => {
                bettingTimerSeconds--;
                bettingTimer.textContent = bettingTimerSeconds;
                if (bettingTimerSeconds <= 5) { bettingTimer.classList.add('timer-warning'); }
                if (bettingTimerSeconds <= 0) {
                    console.log("DEBUG: Betting timer expired!");
                    clearBettingTimer();
                    player1ActionDisplay.textContent = "Timer expired! Auto-calling...";
                    handlePlayer1BetAction('call');
                }
            }, 1000);
        }
        function hideBettingPhase() { clearBettingTimer(); bettingPhaseActive = false; bettingInfo.classList.add('hidden'); bettingControls.classList.add('hidden'); bettingTimerDisplay.classList.add('hidden'); player1ActionDisplay.textContent = ""; player2ActionDisplay.textContent = ""; bettingFeedback.textContent = ""; }
        async function simulatePlayer2Betting() {
             player2ActionDisplay.textContent = "Player 2 is thinking...";
             await new Promise(resolve => setTimeout(resolve, 1200 + Math.random() * 800));
             const p2Decision = player2HasEffectivelyRaised ? 'call' : (Math.random() < 0.5 ? 'raise' : 'call');
             console.log(`DEBUG: P2 Decision (cannot raise if already raised): ${p2Decision}`);
             return p2Decision;
        }

        // Handles Player 1's betting action, triggers Player 2's simulation
        async function handlePlayer1BetAction(player1Action) {
            if (!bettingPhaseActive || !isAnimating) return;
            clearBettingTimer();
            storedPlayer1BetAction = player1Action;
            callButton.disabled = true; raiseButton.disabled = true; forfeitButton.disabled = true; bettingFeedback.textContent = "";

            if (player1Action === 'forfeit') { player1ActionDisplay.textContent = "You chose to Forfeit."; await resolveBettingOutcome(player1Action, null); return; }
            else if (player1Action === 'raise') {
                if (player1HasRaised) { console.log("DEBUG: P1 tried to raise but already has."); bettingFeedback.textContent = "You have already raised this match."; setTimeout(() => bettingFeedback.textContent = '', 2000); callButton.disabled = false; raiseButton.disabled = true; forfeitButton.disabled = false; storedPlayer1BetAction = null; return; }
                if (player1ENJ < raiseAmount) { bettingFeedback.textContent = "Not enough ENJ to raise!"; setTimeout(() => bettingFeedback.textContent = '', 2000); callButton.disabled = false; raiseButton.disabled = player1HasRaised; forfeitButton.disabled = false; storedPlayer1BetAction = null; return; }
                player1ActionDisplay.textContent = "You Raised!"; shootParticles(0.25);
            } else { player1ActionDisplay.textContent = "You Called/Checked."; }

            await new Promise(resolve => setTimeout(resolve, 500));
            const player2Action = await simulatePlayer2Betting();

            if (player2Action === 'raise') { player2ActionDisplay.textContent = `Player 2 Raises!`; shootParticles(0.75); }
            else { player2ActionDisplay.textContent = `Player 2 Calls/Checks.`; }

            await new Promise(resolve => setTimeout(resolve, 1000));
            await resolveBettingOutcome(player1Action, player2Action);
        }

        // Resolves the betting outcome based on both stored actions
        async function resolveBettingOutcome(p1Action, p2Action) {
             clearBettingTimer();
             let proceedToNextRound = false; let insufficientFundsForfeit = false; let finalPot = currentPot;
             let p1RaisedThisPhase = (p1Action === 'raise');
             let p2RaisedThisPhase = (p2Action === 'raise');
             let p1CalledRaise = (p1Action === 'call' && p2Action === 'raise');
             // let p2CalledRaise = (p2Action === 'call' && p1Action === 'raise'); // Not needed for flag update

             console.log(`DEBUG: resolveBettingOutcome Start - Pot: ${currentPot}, P1Action: ${p1Action}, P2Action: ${p2Action}, P1RaisedFlag: ${player1HasRaised}, P2RaisedFlag: ${player2HasEffectivelyRaised}`);

             if (p1Action === 'forfeit') { endGameForfeit(battleAnte); return; }

             // Determine ENJ deduction for THIS phase
             if (p1RaisedThisPhase) { player1ENJ -= raiseAmount; }
             else if (p1CalledRaise) { if (player1ENJ < raiseAmount) { insufficientFundsForfeit = true; } else { player1ENJ -= raiseAmount; } }

             // Update persistent raise flags based on THIS phase's actions
             if (!insufficientFundsForfeit) {
                 if (p1RaisedThisPhase) { player1HasRaised = true; }
                 // Player 2 only counts as "raised" if they explicitly raise in this phase
                 if (p2RaisedThisPhase) { player2HasEffectivelyRaised = true; }
             }

             // Determine final pot and autoPlay based on CUMULATIVE state AFTER this phase
             if (!insufficientFundsForfeit) {
                 // Check if BOTH players have raised at any point up to now
                 if (player1HasRaised && player2HasEffectivelyRaised) {
                     finalPot = raisedPotMutual; // Pot becomes 30
                     autoPlayActive = true; // Activate auto-play!
                     player1ActionDisplay.textContent = "Both players raised! Pot is 30!";
                     player2ActionDisplay.textContent = "Auto-playing remaining rounds...";
                 }
                 // Check if only ONE player has raised cumulatively so far
                 else if (player1HasRaised || player2HasEffectivelyRaised) {
                     finalPot = raisedPotSingle; // Pot becomes/stays 20
                     autoPlayActive = false;
                     if (p1RaisedThisPhase) { player1ActionDisplay.textContent = "You raised, Player 2 called."; player2ActionDisplay.textContent = ""; }
                     else if (p2RaisedThisPhase) { player1ActionDisplay.textContent = "Player 2 raised, you called."; player2ActionDisplay.textContent = "";}
                     else { player1ActionDisplay.textContent = "Action resolved."; player2ActionDisplay.textContent = "";} // Pot was already 20
                 }
                 // Else, neither has ever raised
                 else {
                     finalPot = initialPot; // Pot is 10
                     autoPlayActive = false;
                     player1ActionDisplay.textContent = "Both players checked.";
                     player2ActionDisplay.textContent = "";
                 }
                 proceedToNextRound = true;
             }

             currentPot = finalPot;
             // Set betHasBeenRaised if pot is now > initialPot (used for payout calc)
             if (currentPot > initialPot) { betHasBeenRaised = true; }

             console.log(`DEBUG: Betting Resolved. Pot=${currentPot}, P1Raised=${player1HasRaised}, P2Raised=${player2HasEffectivelyRaised}, AutoPlay=${autoPlayActive}`);

             updateENJBalanceDisplay();
             potDisplay.textContent = currentPot; updateMainPotDisplay();
             await new Promise(resolve => setTimeout(resolve, 100));

             if (insufficientFundsForfeit) { bettingFeedback.textContent = "Not enough ENJ to call raise! Forfeiting."; await new Promise(resolve => setTimeout(resolve, 1500)); endGameForfeit(battleAnte); }
             else if (proceedToNextRound) {
                 hideBettingPhase();
                 if (autoPlayActive) { roundResult.textContent = "Pot raised to 30! Auto-playing..."; await new Promise(resolve => setTimeout(resolve, 1500)); }
                 isAnimating = false; playRound();
             } else { hideBettingPhase(); isAnimating = false; }
         }


        // playRound - Handles round logic, end condition, and betting phase trigger
        async function playRound() {
            if (isAnimating && !bettingPhaseActive) return; isAnimating = true; bettingPhaseActive = false;
            resetCardStyles(); nextRoundButton.classList.add('hidden'); bettingControls.classList.add('hidden'); drawInfo.textContent = ''; roundResult.textContent = 'Choosing...';
            autoPlayIndicator.classList.toggle('hidden', !autoPlayActive);

            // --- Check for Deck Out Conditions at START of round ---
            const p1DeckEmpty = player1BattleDeck.length === 0;
            const p2DeckEmpty = player2BattleDeck.length === 0;

            if (p1DeckEmpty && p2DeckEmpty) { console.log("Both decks empty at start of round."); if (player1Score === player2Score) { handleReplay(); } else { endGame(); } return; }
            else if (p1DeckEmpty) { console.log("P1 deck empty, P2 wins by default."); roundResult.textContent = "Your deck is empty!"; await new Promise(resolve => setTimeout(resolve, 1500)); endGame(); return; }
            else if (p2DeckEmpty) { console.log("P2 deck empty, P1 wins by default."); roundResult.textContent = "Opponent's deck is empty!"; await new Promise(resolve => setTimeout(resolve, 1500)); endGame(); return; }

            roundResult.textContent = 'Choosing...';
            let p1Choice, p2Choice, winner; let isFirstAttempt = true;

            // Draw resolution loop
            while (true) {
                p1Choice = getRandomChoice('player1'); p2Choice = getRandomChoice('player2');
                if (!p1Choice || !p2Choice) { console.log("A player ran out during draw resolution - ending game."); endGame(); return; } // Check again after draw
                if (!isFirstAttempt) { player1Card.classList.remove('winner', 'loser', 'draw'); player2Card.classList.remove('winner', 'loser', 'draw'); roundResult.textContent = 'Re-drawing...'; await new Promise(resolve => setTimeout(resolve, 500)); } else { roundResult.textContent = 'Revealing!'; }
                p1RouletteInterval = startRoulette(player1Card); p2RouletteInterval = startRoulette(player2Card);
                await new Promise(resolve => setTimeout(resolve, 1500));
                stopRoulette(p1RouletteInterval, player1Card, p1Choice); stopRoulette(p2RouletteInterval, player2Card, p2Choice);
                p1RouletteInterval = null; p2RouletteInterval = null;
                winner = determineWinner(p1Choice, p2Choice);
                if (winner === 'draw') { roundResult.textContent = 'Draw!'; player1Card.classList.add('draw'); player2Card.classList.add('draw'); drawInfo.textContent = 'Selecting again...'; isFirstAttempt = false; await new Promise(resolve => setTimeout(resolve, 1500)); }
                else { break; }
            }

            // Winner found for the round
            drawInfo.textContent = ''; await new Promise(resolve => setTimeout(resolve, 300));
            if (winner === 'player1') { player1Score++; console.log(`DEBUG: P1 Score Incremented to: ${player1Score}`); roundResult.textContent = 'Player 1 Wins Round!'; player1Card.classList.add('winner'); player2Card.classList.add('loser'); player1Card.classList.remove('draw'); player2Card.classList.remove('draw'); triggerAttackAnimation(player1Card, 'player1'); }
            else { player2Score++; console.log(`DEBUG: P2 Score Incremented to: ${player2Score}`); roundResult.textContent = 'Player 2 Wins Round!'; player2Card.classList.add('winner'); player1Card.classList.add('loser'); player1Card.classList.remove('draw'); player2Card.classList.remove('draw'); triggerAttackAnimation(player2Card, 'player2'); }
            updateScoreIndicators(); currentRound++;
            await new Promise(resolve => setTimeout(resolve, 600));

            // --- Check Game State After Round ---
            console.log(`End of Round ${currentRound}: P1=${player1Score}, P2=${player2Score}, Max=${maxRounds}, AutoPlay=${autoPlayActive}`);
            if (player1Score >= maxRounds || player2Score >= maxRounds) { console.log(`---> Calling endGame() because score reached ${maxRounds}. Scores: P1=${player1Score}, P2=${player2Score}`); endGame(); }
            else if (autoPlayActive) { roundResult.textContent = "Auto-playing next round..."; await new Promise(resolve => setTimeout(resolve, 1500)); isAnimating = false; playRound(); }
            else { console.log(`---> Triggering Betting Phase before Round ${currentRound + 1}`); showBettingPhase(); }
        }

        // endGame - Payout based on final pot and total ante
        function endGame() {
            console.log(`Game Over Triggered: P1=${player1Score}, P2=${player2Score}, Pot=${currentPot}`);
            const player1Won = player1Score > player2Score; let rewardText = ""; const finalPot = currentPot;
            autoPlayIndicator.classList.add('hidden');

            let player1TotalBet;
            if (autoPlayActive) { player1TotalBet = battleAnte + raiseAmount*2; } // Pot 30 -> P1 Bet 15
            else if (betHasBeenRaised) { player1TotalBet = battleAnte + raiseAmount; } // Pot 20 -> P1 Bet 10
            else { player1TotalBet = battleAnte; } // Pot 10 -> P1 Bet 5
            console.log(`DEBUG: endGame - Pot=${finalPot}, AutoPlay=${autoPlayActive}, BetRaised=${betHasBeenRaised}, P1TotalBet=${player1TotalBet}`);

            if (player1Won) {
                totalWins++; player1ENJ += finalPot; winMessage.textContent = "You Win!"; winMessage.className = "text-5xl font-bold mb-4 text-green-400";
                const netGain = finalPot - player1TotalBet;
                rewardText = `You won the pot: ${finalPot}<span class="enj-coin">E</span> ENJ! (Net: +${netGain}<span class="enj-coin">E</span>)`;
                triggerConfetti();
            } else {
                totalLosses++; winMessage.textContent = "You Lose!"; winMessage.className = "text-5xl font-bold mb-4 text-red-400";
                const amountLost = player1TotalBet;
                rewardText = `You lost ${amountLost}<span class="enj-coin">E</span> ENJ.`;
            }
            winReward.innerHTML = rewardText; updateProfileStats(); winScreen.classList.add('show'); nextRoundButton.classList.add('hidden'); bettingControls.classList.add('hidden'); isAnimating = false;
        }

        // endGameForfeit - Handles forfeit payout
        function endGameForfeit(amountLost = battleAnte) {
             console.log(`Forfeit Triggered: Amount Lost=${amountLost}`);
             autoPlayIndicator.classList.add('hidden');
             totalLosses++; winMessage.textContent = "You Forfeited!"; winMessage.className = "text-5xl font-bold mb-4 text-gray-400";
             winReward.innerHTML = `You lost ${battleAnte}<span class="enj-coin">E</span> ENJ.`; // Forfeit always loses initial ante
             updateProfileStats(); winScreen.classList.add('show'); nextRoundButton.classList.add('hidden'); bettingControls.classList.add('hidden'); isAnimating = false; }


        // Resets state for a *new* match
        function resetForNewMatch() {
             clearBettingTimer();
             player1Score = 0; player2Score = 0; currentRound = 0;
             player1BattleDeck = []; player2BattleDeck = []; initialP1Deck = []; initialP2Deck = [];
             player2Inventory = generateRandomInventoryArray(Math.floor(Math.random() * 10) + 5);
             updateGameInventoryCounts(); resetCardStyles(); updateScoreIndicators();
             roundResult.textContent = ''; drawInfo.textContent = '';
             nextRoundButton.classList.add('hidden'); bettingControls.classList.add('hidden'); bettingInfo.classList.add('hidden');
             autoPlayIndicator.classList.add('hidden');
             if (p1RouletteInterval) clearInterval(p1RouletteInterval); if (p2RouletteInterval) clearInterval(p2RouletteInterval);
             p1RouletteInterval = null; p2RouletteInterval = null;
             isAnimating = false; bettingPhaseActive = false;
             betHasBeenRaised = false; player1HasRaised = false; player2HasEffectivelyRaised = false; autoPlayActive = false;
             currentPot = initialPot;
             storedPlayer1BetAction = null;
        }

        // Shows the My Cards screen
        function showMyCardsScreen() { resetForNewMatch(); updateProfileStats(); displayMyCards(); winScreen.classList.remove('show'); gameArea.classList.add('hidden'); myCardsScreen.classList.remove('hidden'); buyModal.classList.remove('show'); sellModal.classList.remove('show'); buyFeedback.textContent = ''; sellFeedback.textContent = ''; battleStartPopup.classList.remove('show'); anteFeedback.textContent = ''; deckSelectionModal.classList.remove('show'); }

        // --- Deck Selection Functions ---
        function validateDeckSelection() {
            const r = parseInt(deckRCountInput.value) || 0; const p = parseInt(deckPCountInput.value) || 0; const s = parseInt(deckSCountInput.value) || 0; const total = r + p + s;
            deckTotalDisplay.textContent = `Total: ${total} / ${battleDeckSize}`; deckFeedback.textContent = '';
            const invR = player1Inventory['R'] || 0; const invP = player1Inventory['P'] || 0; const invS = player1Inventory['S'] || 0;
            let isValid = true;
            if (total !== battleDeckSize) { deckTotalDisplay.className = 'invalid'; deckFeedback.textContent = `Deck must contain exactly ${battleDeckSize} cards.`; isValid = false; }
            else { deckTotalDisplay.className = 'valid'; if (r > invR) { deckFeedback.textContent = `Not enough Rock cards in inventory (${invR}).`; isValid = false; } else if (p > invP) { deckFeedback.textContent = `Not enough Paper cards in inventory (${invP}).`; isValid = false; } else if (s > invS) { deckFeedback.textContent = `Not enough Scissor cards in inventory (${invS}).`; isValid = false; } }
            confirmDeckButton.disabled = !isValid;
        }
        function showDeckSelection() {
            invRCountEl.textContent = player1Inventory['R'] || 0; invPCountEl.textContent = player1Inventory['P'] || 0; invSCountEl.textContent = player1Inventory['S'] || 0;
            deckRCountInput.value = 4; deckPCountInput.value = 3; deckSCountInput.value = 3;
            deckRCountInput.max = player1Inventory['R'] || 0; deckPCountInput.max = player1Inventory['P'] || 0; deckSCountInput.max = player1Inventory['S'] || 0;
            validateDeckSelection(); deckSelectionModal.classList.add('show');
        }

        // --- Event Listeners ---
        challengeButton.addEventListener('click', async () => { if (isAnimating) return; anteFeedback.textContent = ''; if (player1ENJ < battleAnte) { anteFeedback.textContent = `Insufficient ENJ. Need ${battleAnte} to play.`; setTimeout(() => anteFeedback.textContent = '', 3000); return; } showDeckSelection(); });
        deckRCountInput.addEventListener('input', validateDeckSelection);
        deckPCountInput.addEventListener('input', validateDeckSelection);
        deckSCountInput.addEventListener('input', validateDeckSelection);
        cancelDeckButton.addEventListener('click', () => { deckSelectionModal.classList.remove('show'); });
        confirmDeckButton.addEventListener('click', async () => { validateDeckSelection(); if (confirmDeckButton.disabled) return; player1ENJ -= battleAnte; const r = parseInt(deckRCountInput.value) || 0; const p = parseInt(deckPCountInput.value) || 0; const s = parseInt(deckSCountInput.value) || 0; player1BattleDeck = [ ...Array(r).fill('R'), ...Array(p).fill('P'), ...Array(s).fill('S') ]; initialP1Deck = [...player1BattleDeck]; player2BattleDeck = generateRandomInventoryArray(battleDeckSize); initialP2Deck = [...player2BattleDeck]; console.log("P1 Deck:", player1BattleDeck); console.log("P2 Deck:", player2BattleDeck); currentPot = initialPot; betHasBeenRaised = false; player1HasRaised = false; player2HasEffectivelyRaised = false; autoPlayActive = false; updateENJBalanceDisplay(); updateMainPotDisplay(); updateGameInventoryCounts(); deckSelectionModal.classList.remove('show'); isAnimating = true; myCardsScreen.classList.add('hidden'); gameArea.classList.remove('hidden'); battleStartPopup.classList.add('show'); await new Promise(resolve => setTimeout(resolve, 1800)); battleStartPopup.classList.remove('show'); await new Promise(resolve => setTimeout(resolve, 300)); isAnimating = false; playRound(); });
        nextRoundButton.addEventListener('click', playRound);
        playAgainButton.addEventListener('click', showMyCardsScreen);
        callButton.addEventListener('click', () => handlePlayer1BetAction('call'));
        raiseButton.addEventListener('click', () => handlePlayer1BetAction('raise'));
        forfeitButton.addEventListener('click', () => handlePlayer1BetAction('forfeit'));
        buyButton.addEventListener('click', () => { updateBuySellCurrentCounts(); buyModal.classList.add('show'); buyFeedback.textContent = ''; });
        sellButton.addEventListener('click', () => { updateBuySellCurrentCounts(); sellModal.classList.add('show'); sellFeedback.textContent = ''; });
        buyTypeSelect.addEventListener('change', updateBuySellCurrentCounts);
        sellTypeSelect.addEventListener('change', updateBuySellCurrentCounts);
        buyQuantityInput.addEventListener('input', updateBuySellCurrentCounts);
        sellQuantityInput.addEventListener('input', updateBuySellCurrentCounts);
        cancelBuyButton.addEventListener('click', () => { buyModal.classList.remove('show'); buyFeedback.textContent = ''; });
        cancelSellButton.addEventListener('click', () => { sellModal.classList.remove('show'); sellFeedback.textContent = ''; });
        confirmBuyButton.addEventListener('click', () => { const type = buyTypeSelect.value; const quantity = parseInt(buyQuantityInput.value); const price = calculateCurrentPrice(type); const available = getAvailableSupply(type); const cost = price * quantity; buyFeedback.className = 'modal-feedback feedback-error'; if (!quantity || quantity <= 0) { buyFeedback.textContent = 'Invalid quantity.'; } else if (quantity > available) { buyFeedback.textContent = `Only ${available} available to buy.`; } else if (player1ENJ < cost) { buyFeedback.textContent = 'Insufficient ENJ balance.'; } else { player1ENJ -= cost; player1Inventory[type] = (player1Inventory[type] || 0) + quantity; buyFeedback.className = 'modal-feedback feedback-success'; buyFeedback.textContent = `Bought ${quantity} ${type} for ${cost} ENJ!`; displayMyCards(); setTimeout(() => { buyModal.classList.remove('show'); buyFeedback.textContent = ''; }, 1500); return; } setTimeout(() => buyFeedback.textContent = '', 2500); });
        confirmSellButton.addEventListener('click', () => { const type = sellTypeSelect.value; const quantity = parseInt(sellQuantityInput.value); const price = calculateCurrentPrice(type); const currentOwned = player1Inventory[type] || 0; const earnings = price * quantity; sellFeedback.className = 'modal-feedback feedback-error'; if (!quantity || quantity <= 0) { sellFeedback.textContent = 'Invalid quantity.'; } else if (quantity > currentOwned) { sellFeedback.textContent = 'Cannot sell more than you own.'; } else { player1ENJ += earnings; player1Inventory[type] = currentOwned - quantity; sellFeedback.className = 'modal-feedback feedback-success'; sellFeedback.textContent = `Sold ${quantity} ${type} for ${earnings} ENJ!`; displayMyCards(); setTimeout(() => { sellModal.classList.remove('show'); sellFeedback.textContent = ''; }, 1500); return; } setTimeout(() => sellFeedback.textContent = '', 2500); });

        // --- Initial Setup ---
        showMyCardsScreen(); // Start by showing the My Cards screen

    </script>

</body>
</html>
